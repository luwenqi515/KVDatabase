#include<iostream>
#include<fstream>
#include<string>
#include<map>
#include<windows.h>
#include <cstdlib>

const long MAX_LENGTH = 1000000;
const int KVDB_OK = 0;                        //成功
const int KVDB_INVALID_AOF_PATH = 1;          //路径不存在
const int KVDB_INVALID_KEY = 2;               //key值无效
const int KVDB_INVALID_VALUE = 3;             //value值无效
const int KVDB_NO_SPACE_LEFT_ON_DEVICES = 4;  //磁盘空间不足
const int KVDB_NO_FIND_VALUE = 5;             //未找到value的值

bool Freespace()//判断磁盘是否已满
{
	DWORD64 qwFreeBytes, qwFreeBytesToCaller, qwTotalBytes;
	bool bResult = GetDiskFreeSpaceEx(TEXT("E:"),
		(PULARGE_INTEGER)&qwFreeBytesToCaller,
		(PULARGE_INTEGER)&qwTotalBytes,
		(PULARGE_INTEGER)&qwFreeBytes);
	return bResult;
}
struct item
{
	std::string key;
	int offset;
	item* next;
	item():key("empty"),offset(0),next(NULL){}
	item(std::string k, int o) : key(k), offset(o), next(NULL) {}
};
class Hash
{
private:
	static const int tableSize = 10;
	item* HashTable[tableSize];
public:
	Hash()
	{
		for (int i = 0; i < tableSize; i++)
		{
			HashTable[i] = new item();
			HashTable[i]->key = "empty";
			HashTable[i]->offset = 0;
			HashTable[i]->next = NULL;
		}
	}
	~Hash()
	{
		for (int i = 0; i < tableSize; i++)
		{
			delete HashTable[i];
		}

	}
	int hashFunction(std::string key)
	{
		int sum = 0;
		int index;
		for (int i = 0; i < key.size(); i++)
		{
			sum += static_cast<int>(key[i]);
		}
		index = sum % tableSize;
		return index;
	}
	void AddItem(std::string key, int offset)
	{
		int index = hashFunction(key);
		if (HashTable[index]->key == "empty")
		{
			HashTable[index]->key = key;
			HashTable[index]->offset = offset;
		}
		else
		{
			item* p = HashTable[index];
			item* n = new item(key, offset);
			while (p->next != NULL)
			{
				p = p->next;
			}
			p->next = n;
		}
	}
	int Find(std::string key)
	{
		int index = hashFunction(key);
		bool FindKey = false;
		int offset;
		item* p = HashTable[index];
		while (p != NULL)
		{
			if (p->key == key)
			{
				FindKey = true;
				offset = p->offset;
				break;
			}
			p = p->next;
		}
		return FindKey;
	}
	int GetOffset(std::string key)
	{
		int index = hashFunction(key);
		item* p = HashTable[index];
		while (p != NULL)
		{
			if (p->key == key)
			{
				 return p->offset ;
				 break;
			}
			p = p->next;
		}
	}
	void SetOffset(std::string key,int offset)
	{
		int index = hashFunction(key);
		item* p = HashTable[index];
		while (p != NULL)
		{
			if (p->key == key)
			{
				p->offset = offset;
				break;
			}
			p = p->next;
		}
	}
	void RemoveItem(std::string key)
	{
		int index = hashFunction(key);

		item* delPtr;
		item* p1;
		item* p2;

		
		if (HashTable[index]->key == key &&HashTable[index]->next == NULL)
		{
			HashTable[index]->key = "empty";
			HashTable[index]->offset = 0;
		}
		
		else if (HashTable[index]->key == key)
		{
			delPtr = HashTable[index];
			HashTable[index] = HashTable[index]->next;
			delete delPtr;
		}
		
		else
		{
			p1 = HashTable[index]->next;
			p2 = HashTable[index];
			while (p1 != NULL && p1->key != key)
			{
				p2 = p1;
				p1 = p1->next;
			}
			
			delPtr = p1;
			p1 = p1->next;
			p2->next = p1;
			delete delPtr;
		}
	}
};
class KVDBHandler
{
private:
	std::string filename;
	Hash hash;
public:
	KVDBHandler(const std::string& db_file)
	{
		filename = db_file;
		std::cout << "正在打开数据库..." << std::endl;
		std::fstream file;
		file.open(filename, std::ios::in | std::ios::out | std::ios::binary);
		if (!file)
		{
			std::cout << "数据库不存在,已创建新的数据库！" << std::endl;
			std::ofstream newfile(filename);
			newfile.close();
		}
		else
			std::cout << "数据库打开成功！" << std::endl;
		file.close();
		getHash();
	}
	~KVDBHandler()
	{
		filename.clear();
	}
	
	long getLength()//获取文件大小
	{
		std::ifstream in(filename);
		in.seekg(0, std::ios::end);
		std::streampos ps = in.tellg();
		in.close();
		return ps;

	}
	void getHash()
	{
		std::fstream file;
		file.open(filename, std::ios::in | std::ios::binary);
		int klen, vlen;
		char* str_key, * str_value;
		int offset = 0;
		while (file.read((char*)&klen, sizeof(int)))
		{
			offset += sizeof(int);
			file.read((char*)&vlen, sizeof(int));
			offset += sizeof(int);
			str_key = new char[klen + 1];
			file.read(str_key, klen);
			offset += klen;
			str_key[klen] = 0;
			//std::cout <<"str_key:"<< str_key <<std::endl;

			if (vlen >= 1)
			{
				file.seekg(vlen, std::ios::cur);
				int flag=hash.Find(str_key);
				if (flag == true)
				{
					hash.SetOffset(str_key, offset);
				}
				else 
				{
					hash.AddItem(str_key, offset);
				}
				offset += vlen;
				delete[]str_key;
			}
			else
			{
				hash.RemoveItem (str_key);
			}
		}
	}
	friend int set(KVDBHandler* handler, const std::string& key, const std::string& value);
	friend int get(KVDBHandler* handler, const std::string& key, std::string& value);
	friend int del(KVDBHandler* handler, const std::string& key);
    friend int purge(KVDBHandler* handler);
};
int set(KVDBHandler* handler, const std::string& key, const std::string& value)
{
	std::fstream file;
	file.open(handler->filename,std::ios::out | std::ios::binary|std::ios::app);
	if (!file)
		return KVDB_INVALID_AOF_PATH;
	else
	{
		int klen, vlen;
		klen = key.length();
		vlen = value.length();
		if (klen == 0)
		{
			file.close();
			return KVDB_INVALID_KEY;
		}
		else if (!Freespace())
		{
			file.close();
			return KVDB_NO_SPACE_LEFT_ON_DEVICES;
		}
		else
		{
			file.seekg(0,std::ios::end);
			int offset = file.tellg();
			file.write((char*)&klen, sizeof(int));
			offset += sizeof(int);
			file.write((char*)&vlen, sizeof(int));
			offset += sizeof(int);
			file.write(key.c_str(), klen);
			offset += klen;
			file.write(value.c_str(), vlen);
			file.close();
			if (handler->hash.Find(key))
			{
				handler->hash.SetOffset(key,offset);
			}
			else
			{
				handler->hash.AddItem(key, offset);
			}
			return KVDB_OK;
		}
	}
}
int get(KVDBHandler* handler, const std::string& key, std::string& value)
{
	std::fstream file;
	file.open(handler->filename ,std::ios::in | std::ios::binary);
	if (!file)
		return KVDB_INVALID_AOF_PATH;
	else
	{
		if (key.length() == 0)
		{
			file.close();
			return KVDB_INVALID_KEY;
		}
		else
		{
			if (handler->hash.Find(key))
			{
				int offset=handler->hash.GetOffset(key);
				int vlen;
				file.seekg(offset-key.length ()-sizeof(int), std::ios::beg);//定位到vlen
				file.read((char*)&vlen,sizeof(int));
				file.seekg(key.length(), std::ios::cur);//定位到value
				char* str_value;
				str_value = new char[vlen + 1];
				file.read(str_value, vlen);
				str_value[vlen] = 0;
				value = str_value;
				delete[]str_value;
				file.close();
				return KVDB_OK;
			}
			else
			{
				file.close();
				return KVDB_NO_FIND_VALUE;
			}
			/*   stage1的get
			int klen, vlen;
			char* str_key, * str_value;
			while (file.read((char*)&klen, sizeof(int)))
			{
				file.read((char*)&vlen, sizeof(int));
				//std::cout << klen << " " << vlen << std::endl;
				str_key = new char[klen + 1];
				file.read(str_key, klen);
				str_key[klen] = 0;
				//std::cout <<"str_key:"<< str_key <<std::endl;
				if (vlen == -1)
				{
					if (str_key == key)
					{
						value.clear();
					}
				}
				else
				{
					if (str_key == key)
					{
						value.clear();
						str_value = new char[vlen + 1];
						file.read(str_value, vlen);
						str_value[vlen] = 0;
						//std::cout << str_value << std::endl;
						value = str_value;
						delete[]str_key;
						delete[]str_value;
					}
					else
					{
						file.seekg(vlen, std::ios::cur);
					}
				}
			}
			file.close();
			if (value.empty())
				return KVDB_NO_FIND_VALUE;
			else
				return KVDB_OK;
				*/
		}
	}
}
int del(KVDBHandler* handler, const std::string& key)
{
	std::fstream file;
	file.open(handler->filename ,std::ios::out | std::ios::binary | std::ios::app);
	if (!file)
		return KVDB_INVALID_AOF_PATH;
	else
	{
		int klen, vlen;
		klen = key.length();
		vlen = -1;
		if (klen == 0)
		{
			file.close();
			return KVDB_INVALID_KEY;
		}
		else
		{
			file.write((char*)&klen, sizeof(int));
			file.write((char*)&vlen, sizeof(int));
			file.write(key.c_str(), klen);
			file.close();
			handler->hash.RemoveItem(key);
			return KVDB_OK;
		}
	}
}
int purge(KVDBHandler* handler)
{
	std::fstream file;
	file.open(handler->filename, std::ios::in | std::ios::binary);
	if (!file)
		return KVDB_INVALID_AOF_PATH;
	else
	{
		std::map<std::string, std::string> data;
		std::pair<std::map<std::string, std::string>::iterator, bool > Insert_Pair;
		int klen, vlen;
		char* str_key, * str_value;
		while (file.read((char*)&klen, sizeof(int)))
		{
			file.read((char*)&vlen, sizeof(int));
			//std::cout << klen << " " << vlen << std::endl;
			str_key = new char[klen + 1];
			file.read(str_key, klen);
			str_key[klen] = 0;
			//std::cout <<"str_key:"<< str_key <<std::endl;

			if (vlen >= 1)
			{
				str_value = new char[vlen + 1];
				file.read(str_value, vlen);
				str_value[vlen] = 0;
				//std::cout << str_value << std::endl;
				Insert_Pair = data.insert(std::pair<std::string, std::string>(str_key, str_value));
				if (Insert_Pair.second == false)
				{
					data[str_key] = str_value;
				}
				delete[]str_key;
				delete[]str_value;
			}
			else
			{
				data.erase(str_key);
			}
		}
		std::string file_name = handler->filename;
		std::ofstream file_writer(file_name, std::ios_base::out);

		for (auto it = data.begin(); it != data.end(); it++)
		{
			set(handler, it->first, it->second);
			//std::cout << it->first << " " << it->second << std::endl;
		}
		data.clear();
		file.close();
		return KVDB_OK;
	}
}

int main()
{
	std::string file;
	std::cout << "请输入要打开的数据库：";
	std::cin>>file;
	int flag;
	KVDBHandler handler((const std::string)file);
	int command;
	while (true)
	{
		std::cout << "请输入操作命令:\n";
		std::cout << "             [1]写入" << std::endl;
		std::cout << "             [2]读取" << std::endl;
		std::cout << "             [3]删除" << std::endl;
		std::cout << "             [4]退出" << std::endl;
		std::cin >> command;
		getchar();
		if(command==1)
		{
			std::string key, value;
			std::cout << "请输入key和value：" << std::endl;
			getline(std::cin,key);
			getline(std::cin, value);
			flag=set(&handler, key, value);
			if (flag == 0)
				std::cout << "写入成功！" << std::endl;
			else if (flag == 1)
			{
				std::cout << "路径不存在！" << std::endl;
			}
			else if (flag == 2)
			{
				std::cout << "KEY无效，请重新操作！" << std::endl;
			}
			else if (flag == 4)
			{
				std::cout << "磁盘已满，无法写入！" << std::endl;
			}
			system("pause");
			system("cls");
		}
		else if(command==2)
		{
			std::string key, value;
			std::cout << "请输入key:" << std::endl;
			//std::cin >> key;
			getline(std::cin, key);
			//std::cout << key << std::endl;
			int flag;
			flag = get(&handler, key, value);
			if (flag == 0)
			{
				std::cout << "读取成功！" << std::endl;
				std::cout << key << "对应的value为：" << value << std::endl;
			}
			else if (flag == 1)
			{
				std::cout << "路径不存在！" << std::endl;
			}
			else if (flag == 2)
			{
				std::cout << "KEY无效，请重新操作！"  << std::endl;
			}
			else if (flag == 5)
			{
				std::cout << "未读取到key相关的value！" << std::endl;
			}
			system("pause");
			system("cls");
		}
		else if (command == 3)
		{
			std::string key;
			std::cout << "请输入需要删除的key:" << std::endl;
			//std::cin >> key;
			getline(std::cin, key);
			int flag;
			flag = del(&handler, key);
			if (flag == 0)
			{
				std::cout << "删除成功！" << std::endl;
			}
			else if (flag == 1)
			{
				std::cout << "路径不存在！" << std::endl;
			}
			else if (flag == 2)
			{
				std::cout << "KEY无效，请重新操作！" << std::endl;

			}
			system("pause");
			system("cls");
		}
		else if (command == 4)
		{
			exit(0);
		}
		else
		{
			std::cout << "       Command Error！请重新输入！" << std::endl;
			system("pause");
			system("cls");
		}
		if (handler.getLength() > MAX_LENGTH)
		{
			flag=purge(&handler);
			if (flag == 0)
				std::cout << "文件过大，已整理完毕！" << std::endl;
			else if (flag == 1)
			{
				std::cout << "文件过大，路径不存在无法整理！" << std::endl;
			}
		}
		
	}
	return 0;
}
