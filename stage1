#include<iostream>
#include<fstream>
#include<string>
#include<map>
#include<windows.h>

const int KVDB_OK = 0;
const int KVDB_INVALID_AOF_PATH = 1;
const int KVDB_INVALID_KEY = 2;
const int KVDB_INVALID_VALUE = 3;
const int KVDB_NO_SPACE_LEFT_ON_DEVICES = 4;
const int KVDB_NO_FIND_VALUE = 5;

bool Freespace()
{
	DWORD64 qwFreeBytes, qwFreeBytesToCaller, qwTotalBytes;
	bool bResult = GetDiskFreeSpaceEx(TEXT("E:"),
		(PULARGE_INTEGER)&qwFreeBytesToCaller,
		(PULARGE_INTEGER)&qwTotalBytes,
		(PULARGE_INTEGER)&qwFreeBytes);
	return bResult;
}

class KVDBHandler
{
private:
	std::ifstream ifile;
	std::ofstream ofile;
	std::string filename;
public:
	KVDBHandler(const std::string& db_file,int &state)
	{
		std::cout << "正在打开数据库..." << std::endl;
		ifile.open(db_file,std::ios::in|std::ios::binary);
		if (!ifile)
		{
			//std::cout << "数据库不存在,已创建新的数据库！" << std::endl;
			state= KVDB_INVALID_AOF_PATH;
			std::ofstream _ofile(db_file);
			_ofile.close();
		}
		else
		    state = 0;
		ofile.open(db_file, std::ios::app | std::ios::binary);
		filename = db_file;
	}
	~KVDBHandler()
	{
		ifile.close();
		ofile.close();
	}
	friend int set(KVDBHandler* handler, const std::string& key, const std::string& value);
	friend int get(KVDBHandler* handler, const std::string& key, std::string& value);
	friend int del(KVDBHandler* handler, const std::string& key);
    friend void purge(KVDBHandler* handler);
	friend void getIndex(KVDBHandler* handler);

};
int set(KVDBHandler* handler, const std::string& key, const std::string& value)
{
	int klen, vlen;
	klen = key.length();
	vlen = value.length();
	if (klen == 0)
		return KVDB_INVALID_KEY;
	else if (vlen == 0)
		return KVDB_INVALID_VALUE;
	else if(!Freespace())
		return KVDB_NO_SPACE_LEFT_ON_DEVICES;
	else
	{
		handler->ofile.write((char*)&klen, sizeof(int));
		handler->ofile.write((char*)&vlen, sizeof(int));
		handler->ofile.write(key.c_str(), klen);
		handler->ofile.write(value.c_str(), vlen);
		return KVDB_OK;
	}
}
int get(KVDBHandler* handler, const std::string& key, std::string& value)
{
	if (key.length () == 0)
		return KVDB_INVALID_KEY;
	else
	{
		int klen, vlen;
		char* str_key, * str_value;
		while (handler->ifile.read((char*)&klen, sizeof(int)))
		{
			handler->ifile.read((char*)&vlen, sizeof(int));
			//std::cout << klen << " " << vlen << std::endl;

			str_key = new char[klen + 1];
			handler->ifile.read(str_key, klen);
			str_key[klen] = 0;
			//std::cout <<"str_key:"<< str_key <<std::endl;

			if (str_key == key)
			{
				str_value = new char[vlen + 1];
				handler->ifile.read(str_value, vlen);
				str_value[vlen] = 0;
				//std::cout << str_value << std::endl;
				value = str_value;
				delete[]str_key;
				delete[]str_value;
			}
			else
			{
				handler->ifile.seekg(vlen, std::ios::cur);
			}

		}
		if (value.empty())
			return KVDB_NO_FIND_VALUE;
		else
			return KVDB_OK;
	}
}
int del(KVDBHandler* handler, const std::string& key)
{
	int klen, vlen;
	klen = key.length();
	vlen = -1;
	if (klen == 0)
	{
		return KVDB_INVALID_KEY;
	}
	else
	{
		handler->ofile.write((char*)&klen, sizeof(int));
		handler->ofile.write((char*)&vlen, sizeof(int));
		handler->ofile.write(key.c_str(), klen);
		return KVDB_OK;
	}
}
void purge(KVDBHandler* handler)
{
	std::map<std::string, std::string> data;
	std::pair<std::map<std::string, std::string>::iterator,bool > Insert_Pair;
	int klen, vlen;
	char* str_key, * str_value;
	while (handler->ifile.read((char*)&klen, sizeof(int)))
	{
		handler->ifile.read((char*)&vlen, sizeof(int));
		//std::cout << klen << " " << vlen << std::endl;
		str_key = new char[klen + 1];
		handler->ifile.read(str_key, klen);
		str_key[klen] = 0;
		//std::cout <<"str_key:"<< str_key <<std::endl;

		if(vlen>=1)
		{
			str_value = new char[vlen + 1];
			handler->ifile.read(str_value, vlen);
			str_value[vlen] = 0;
			//std::cout << str_value << std::endl;
			Insert_Pair=data.insert(std::pair<std::string, std::string>(str_key, str_value));
			if (Insert_Pair.second == false)
			{
				data[str_key] = str_value;
			}
			delete[]str_key;
			delete[]str_value;
		}
		else
		{
			data.erase(str_key);
		}
	}
	std::string file_name = handler->filename;
	std::ofstream file_writer(file_name, std::ios_base::out);
	
	for (auto it = data.begin(); it != data.end(); it++)
	{
		set(handler, it->first, it->second);
		//std::cout << it->first << " " << it->second << std::endl;
	}
	data.clear();
}

int main()
{
	std::string file;
	std::cout << "请输入要打开的数据库：";
	std::cin>>file;
	//KVDBHandler handler((const std::string)file);
	int command;
	while (true)
	{
		int flag;
		KVDBHandler handler((const std::string)file,flag);
		if (flag == 1)
		{
			std::cout << "数据库不存在,已创建新的数据库！" << std::endl;
		}
		else if(flag==0)
		{
			std::cout << "数据库打开成功！" << std::endl;
		}
		std::cout << "请输入操作命令:\n";
		std::cout << "             [1]写入" << std::endl;
		std::cout << "             [2]读取" << std::endl;
		std::cout << "             [3]删除" << std::endl;
		std::cout << "             [4]整理" << std::endl;
		std::cout << "             [5]退出" << std::endl;
		std::cin >> command;
		getchar();
		if(command==1)
		{
			std::string key, value;
			std::cout << "请输入key和value：" << std::endl;
			getline(std::cin,key);
			getline(std::cin, value);
			//std::cin >> key >> value;
			flag=set(&handler, key, value);
			if (flag == 0)
				std::cout << "写入成功！" << std::endl;
			else if (flag == 2)
			{
				std::cout << "KEY无效，请重新操作！" << std::endl;
			}
			else if (flag == 3)
			{
				std::cout << "VALUE无效，请重新操作！"  << std::endl;
			}
			else if (flag == 4)
			{
				std::cout << "磁盘已满，无法写入！" << std::endl;
			}
			system("pause");
			system("cls");
		}
		else if(command==2)
		{
			std::string key, value;
			std::cout << "请输入key:" << std::endl;
			//std::cin >> key;
			getline(std::cin, key);
			//std::cout << key << std::endl;
			int flag;
			flag = get(&handler, key, value);
			if (flag == 0)
			{
				std::cout << "读取成功！" << std::endl;
				std::cout << key << "对应的value为：" << value << std::endl;
			}
			else if (flag == 2)
			{
				std::cout << "KEY无效，请重新操作！"  << std::endl;
			}
			else if (flag == 5)
			{
				std::cout << "未读取到key相关的value！" << std::endl;
			}
			system("pause");
			system("cls");
		}
		else if (command == 3)
		{
			std::string key;
			std::cout << "请输入需要删除的key:" << std::endl;
			//std::cin >> key;
			getline(std::cin, key);
			int flag;
			flag = del(&handler, key);
			if (flag == 0)
			{
				std::cout << "删除成功！" << std::endl;
			}
			else if (flag == 2)
			{
				std::cout << "KEY无效，请重新操作！" << std::endl;

			}
			system("pause");
			system("cls");
		}
		else if (command == 5)
		{
			exit(0);
		}
		else if (command == 4)
		{
			purge(&handler);
			std::cout << "文件整理成功！" << std::endl;
			system("pause");
			system("cls");
		}
		else
		{
			std::cout << "       Command Error！请重新输入！" << std::endl;
			system("pause");
			system("cls");
		}
	}
	return 0;
}
